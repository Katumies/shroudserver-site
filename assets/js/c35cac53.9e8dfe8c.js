"use strict";(globalThis.webpackChunkshroudserver=globalThis.webpackChunkshroudserver||[]).push([[885],{582:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/wireshark-4932cf609fc8f195a89ab0e4e52d29b0.jpg"},1470:(e,n,t)=>{t.d(n,{A:()=>E});var r=t(6540),a=t(4164),o=t(7559),i=t(3104),s=t(6347),l=t(205),c=t(7485),d=t(1682),h=t(679);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function g({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(a),(0,r.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})},[a,t])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=p(e),[i,s]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:o})),[c,d]=g({queryString:t,groupId:a}),[u,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,a]=(0,h.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),f=(()=>{const e=c??u;return m({value:e,tabValues:o})?e:null})();(0,l.A)(()=>{f&&s(f)},[f]);return{selectedValue:i,selectValue:(0,r.useCallback)(e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),b(e)},[d,b,o]),tabValues:o}}var f=t(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var N=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:r,tabValues:o}){const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),c=e=>{const n=e.currentTarget,a=s.indexOf(n),i=o[a].value;i!==t&&(l(n),r(i))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,N.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:r})=>(0,N.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{s.push(e)},onKeyDown:d,onClick:c,...r,className:(0,a.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function O({lazy:e,children:n,selectedValue:t}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,N.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function w(e){const n=b(e);return(0,N.jsxs)("div",{className:(0,a.A)(o.G.tabs.container,"tabs-container",v.tabList),children:[(0,N.jsx)(y,{...n,...e}),(0,N.jsx)(O,{...n,...e})]})}function E(e){const n=(0,f.A)();return(0,N.jsx)(w,{...e,children:u(e.children)},String(n))}},6129:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>h});var r=t(7747),a=t(4848),o=t(8453),i=t(1470),s=t(9365);const l={title:"ENet modifications and reverse engineering",description:"Technical deep dive into ENet modifications needed for ShroudServer.",date:new Date("2025-10-19T00:00:00.000Z"),authors:"katumies",tags:["me","csharp","networking","enet"]},c=void 0,d={authorsImageUrls:[void 0]},h=[{value:"Enet modifications",id:"enet-modifications",level:2},{value:"Background",id:"background",level:3},{value:"Reverse engineering",id:"reverse-engineering",level:3},{value:"Actual reverse engineering",id:"actual-reverse-engineering",level:4},{value:"BepInEx plugin",id:"bepinex-plugin",level:4},{value:"Wireshark",id:"wireshark",level:4},{value:"ENet modifications",id:"enet-modifications-1",level:2},{value:"Main differences",id:"main-differences",level:4},{value:"ProtocolCommands are almost equal",id:"protocolcommands-are-almost-equal",level:5},{value:"Protocol Headers differ",id:"protocol-headers-differ",level:5},{value:"Connection handshake commands",id:"connection-handshake-commands",level:5},{value:"The final result",id:"the-final-result",level:2},{value:"Next steps?",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"enet-modifications",children:"Enet modifications"}),"\n",(0,a.jsxs)(n.p,{children:["Yesterday and today, I have been working on modifying ",(0,a.jsx)(n.a,{href:"https://github.com/Molth/enet-csharp",children:"ENet-CSharp"})," library to work with SotA.\r\nI'll go through the changes needed and why they were needed."]}),"\n",(0,a.jsx)(n.p,{children:"Warning, this is going to be a very technical post."}),"\n",(0,a.jsx)(n.h3,{id:"background",children:"Background"}),"\n",(0,a.jsx)(n.p,{children:"SotA uses Photon networking for all the networking needs. The server they are running is Photon Server v4, and the client\r\nuses Photon Unity Networking V1. How do I know all this? Well, I took a look at the game files, and there it is, Photon3Unity3D.dll.\r\nThis is the client library for Photon networking. I have spent a few years, with varying interest, to dig out how the game works\r\nand more importantly, how the networking works."}),"\n",(0,a.jsx)(n.h3,{id:"reverse-engineering",children:"Reverse engineering"}),"\n",(0,a.jsx)(n.p,{children:"Hours and hours of using Wireshark, DotPeek, DnSpy and other tools, I have managed to get a good understanding\r\nof the networking protocol used by the game. There is not a lot of public information about the protocol used by Photon,\r\nso I had to do a lot of things by myself. Luckily, this year, there been some other projects that have been working on\r\nPhoton emulation, and I have been able to learn from them as well. However, none of those tackled the actual ENet modification,\r\nbut rather focused on emulating the server. Nothing wrong about that, but I wanted to go deeper."}),"\n",(0,a.jsx)(n.h4,{id:"actual-reverse-engineering",children:"Actual reverse engineering"}),"\n",(0,a.jsx)(n.p,{children:"What do I actually do when I say reverse engineering?"}),"\n",(0,a.jsx)(n.p,{children:"For example, the last few days, I have been working on understanding how the reliable messages are sent and received and also,\r\nhow the acknowledgements are handled. This required hours of looking and tracing the code to actually understand that it really\r\nmatters that acknowledgements are sent in a specific way. This is one of the modifications ENet needed. I also spent used Wireshark\r\nto capture and record the actual packets sent by the client, when it's connecting at the game start and also, what the server answers.\r\nI saved those packets and used Wireshark to analyze them."}),"\n",(0,a.jsx)(n.p,{children:"Normally, all networking messages are obfuscated, but I have disabled that with the BepInEx plugin I have created for the client.\r\nThey obfuscate it by adding a random variable number of random bytes to the start and end or the actual message.\r\nThen there are a few places where they drop byte '55' (0x37) to work as a marker. Nothing fancy, but it works, I guess.\r\nIt surely stops casual packet sniffing. However, they could have enabled encryption also, or instead of sending JSON data,\r\nthey could have used a binary format."}),"\n",(0,a.jsx)(n.h4,{id:"bepinex-plugin",children:"BepInEx plugin"}),"\n",(0,a.jsx)(n.p,{children:"To help with the reverse engineering, I created a BepInEx plugin for the client. It's nothing fancy, but it changes all\r\nthe addresses the client uses to connect servers and point those addresses to my localhost. I also have added logging here\r\nand there to get more information about what the client is doing. I found a way to swap the encryption keys, so I don't have\r\nto disable encryption used for login passwords etc. I patch the obfuscation method, so it takes a byte array and\r\njust returns it as is, instead of adding random bytes."}),"\n",(0,a.jsx)(n.p,{children:"BepInEx is a great modding framework for Unity games, and we are going to use it a lot in this project.\r\nSo much could be done with it already."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["adding custom UI's","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"totally new windows that aggregate information from multiple sources"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["modding existing UI's","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"sorting changes"}),"\n",(0,a.jsx)(n.li,{children:"adding new buttons that simplify things"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["adding new Lua features","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"literally anything can be connected to lua scripts within the game data"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"fixing existing issues with the client."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"I did say, that this is going to be a technical post, so for the fellow nerds, here is the code snippet that patches the obfuscation method:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'    // Find the type information for the PortMessage class\r\n    Type type = Type.GetType("Portalarium.Photon.PortMessage, Assembly-CSharp");\r\n    \r\n    // Use type information to get the MethodInfo for the CreateByteArrayData method\r\n    MethodInfo createByteArrayDataMethodInfo = type.GetMethod("CreateByteArrayData", BindingFlags.NonPublic | BindingFlags.Static);\r\n    \r\n    // use Harmony to patch the method\r\n\tvar instance = new Harmony("tester");\r\n\tinstance.Patch(\r\n\t\tcreateByteArrayDataMethodInfo,\r\n\t\tnew HarmonyMethod(typeof(PatchObfuscation).GetMethod("Prefix")),\r\n\t\tnull,\r\n\t\tnull\r\n\t\t);\r\n\r\n    // this is BepInEx Harmony patch class\r\n   public class PatchObfuscation\r\n    {\r\n        // Prefix, executed before the original method, with the ability to modify parameters, reroute execution or set return value.\r\n        public static bool Prefix(ref DataBuffer __result, MethodBase __originalMethod, char[] SerializedData, int length)\r\n        {\r\n            // Here we create new return value for the method and instead of obfuscating the data, we just convert it to DataBuffer as is.\r\n            byte[] returnValue = new byte[length];\r\n            Encoding.UTF8.GetBytes(SerializedData, 0, length, returnValue, 0);\r\n            DataBuffer dataBuffer = new DataBuffer(returnValue);\r\n            __result = dataBuffer;\r\n\r\n            // return false means, that the original method is not executed.\r\n            return false;\r\n        }\r\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"BepInEx is a really powerful tool, and I recommend it for anyone wanting to mod Unity games."}),"\n",(0,a.jsx)(n.h4,{id:"wireshark",children:"Wireshark"}),"\n",(0,a.jsxs)(n.p,{children:["With Wireshark, I can see what kind of packets are sent between the client and the server. I use ",(0,a.jsx)(n.a,{href:"https://github.com/bennesp/photon-dissector",children:"photon-dissector"}),"\r\nwith tiny modifications to make it work with this photon version. It is a sort of plugin for Wireshark that allows it to understand and decode\r\nthe Photon protocol."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Wireshark screenshot",src:t(582).A+"",width:"1502",height:"758"})}),"\n",(0,a.jsx)(n.h2,{id:"enet-modifications-1",children:"ENet modifications"}),"\n",(0,a.jsx)(n.p,{children:"So, as previously stated, Photon is built on top of ENet. ENet is the actual networking part of the code. It reads and writes packets\r\nto and from the sockets, using UDP protocol. I'm not going to cover UDP and socket programming, but I will cover the ENet part.\r\nOne thing to remember is that Photon is a HUGE software that can do so much more than just UDP networking, so we are not replacing all the\r\nfeatures of Photon, only the important ones, UDP layer."}),"\n",(0,a.jsx)(n.h4,{id:"main-differences",children:"Main differences"}),"\n",(0,a.jsx)(n.p,{children:"At this time, I can't even list all the differences because I may discover more in the future. However, SotA client accepts my\r\nserver and starts to communicate with it, so I can assume that the biggest differences have been fixed."}),"\n",(0,a.jsx)(n.h5,{id:"protocolcommands-are-almost-equal",children:"ProtocolCommands are almost equal"}),"\n",(0,a.jsx)(n.p,{children:"Realizing that the protocol at very low level is almost the same for both Photon and Enet, gave me the confidence that this is doable.\r\nThese are the protocol commands that are used by both libraries."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"ENet",label:"ENet",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public enum ENetProtocolCommand\r\n{\r\n    ENET_PROTOCOL_COMMAND_NONE = 0,\r\n    ENET_PROTOCOL_COMMAND_ACKNOWLEDGE = 1,\r\n    ENET_PROTOCOL_COMMAND_CONNECT = 2,\r\n    ENET_PROTOCOL_COMMAND_VERIFY_CONNECT = 3,\r\n    ENET_PROTOCOL_COMMAND_DISCONNECT = 4,\r\n    ENET_PROTOCOL_COMMAND_PING = 5,\r\n    ENET_PROTOCOL_COMMAND_SEND_RELIABLE = 6,\r\n    ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE = 7,\r\n    ENET_PROTOCOL_COMMAND_SEND_FRAGMENT = 8,\r\n    ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED = 9,\r\n    ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT = 10,\r\n    ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11,\r\n    ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,\r\n    ENET_PROTOCOL_COMMAND_COUNT = 13,\r\n\r\n    ENET_PROTOCOL_COMMAND_MASK = 0x0F\r\n}\n"})})}),(0,a.jsx)(s.A,{value:"Photon",label:"Photon",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public enum PhotonProtocolCommand\r\n{\r\n    PHOTON_PROTOCOL_COMMAND_NONE = 0,\r\n    PHOTON_PROTOCOL_COMMAND_ACKNOWLEDGE = 1,\r\n    PHOTON_PROTOCOL_COMMAND_CONNECT = 2,\r\n    PHOTON_PROTOCOL_COMMAND_VERIFY_CONNECT = 3,\r\n    PHOTON_PROTOCOL_COMMAND_DISCONNECT = 4,\r\n    PHOTON_PROTOCOL_COMMAND_PING = 5,\r\n    PHOTON_PROTOCOL_COMMAND_SEND_RELIABLE = 6,\r\n    PHOTON_PROTOCOL_COMMAND_SEND_UNRELIABLE = 7,\r\n    PHOTON_PROTOCOL_COMMAND_SEND_FRAGMENT = 8,\r\n    PHOTON_PROTOCOL_COMMAND_SEND_UNSEQUENCED = 9,\r\n    //PHOTON_PROTOCOL_COMMAND_BANDWIDTH_LIMIT = 10,\r\n    //PHOTON_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11,\r\n    //PHOTON_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,\r\n    PHOTON_PROTOCOL_COMMAND_SEND_SERVERTIMESTAMP = 12,\r\n    PHOTON_PROTOCOL_COMMAND_COUNT = 13,\r\n\r\n    PHOTON_PROTOCOL_COMMAND_MASK = 0x0F\r\n}\n"})})})]}),"\n",(0,a.jsx)(n.h5,{id:"protocol-headers-differ",children:"Protocol Headers differ"}),"\n",(0,a.jsx)(n.p,{children:"A Big difference between the two protocols is the actual protocol headers used. Photon has more information in the header.\r\nENet uses bit-fields to encode data to, for example, peerID. So, the actual maximum peerID is 0xFFF because the last bit\r\nis used for bit flags."}),"\n",(0,a.jsx)(n.p,{children:"Photon has explicit bytes reserved for things needed. It looks like ENet is more efficient, but Photon delivers much more\r\ncomplicated data, and it packs the data better, so in the real world, it's probably more efficient after all."}),"\n",(0,a.jsx)(n.p,{children:"PeerID functionality and commandCount things caused refactorings here and there. I tried to find a way to make them work\r\nall the while keeping ENets features in use. Also, ENet uses the sessionID variable to keep track of the connection, but Photon\r\nuses the challenge variable. Photon Marks the packets as reliable by using the command flags and CommandType."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"ENet",label:"ENet",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// 8 bytes\r\npublic struct ENetProtocolHeader\r\n{\r\n    public ushort peerID;\r\n    public ushort sentTime;\r\n}\r\n\r\n// 6 bytes\r\npublic struct ENetProtocolCommandHeader\r\n{\r\n    public byte command;\r\n    public byte channelID;\r\n    public uint reliableSequenceNumber;\r\n}\n"})})}),(0,a.jsx)(s.A,{value:"Photon",label:"Photon",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// 12 bytes\r\npublic struct PhotonProtocolHeader\r\n{\r\n    public ushort peerID;\r\n    public byte crcEnabled;\r\n    public byte commandCount;\r\n    public uint sentTime;\r\n    public uint challenge;\r\n}\r\n// 12 bytes\r\npublic struct PhotonProtocolCommandHeader\r\n{\r\n    public byte commandType;\r\n    public byte channelID;\r\n    public byte commandFlags;\r\n    public byte reservedBytes;\r\n    public uint commandLen;\r\n    public uint reliableSequenceNumber;\r\n}\n"})})})]}),"\n",(0,a.jsx)(n.h5,{id:"connection-handshake-commands",children:"Connection handshake commands"}),"\n",(0,a.jsx)(n.p,{children:'ENet has a very different connection handshake. ENet sends tons of data and uses fields that are not present in Photon.\r\nENet client decides its own ID, where as Photon uses incremental ID, assigned by the server.\r\nSotA clients PUN sends very few fields, most of the "connect" data is 0.\r\nAlso, when the SotA client receives the "Verify connect" command, it basically ignores everything from the payload.\r\nIt only reads two first bytes of it as a peerID.'}),"\n",(0,a.jsx)(n.p,{children:'One big thing I had to change was that acknowledgement for the "connect" command has to be in the next message sent and\r\nit has to be before "verify connect" in the list of commands. Client reads incoming commands in the order they are sent and if\r\n"verify connect" is received before the "connect" is acknowledged, it sends the "connect" command again. This is just a one example\r\nof things that just have to be dug out with reverse engineering.'}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"ENet",label:"ENet",default:!0,children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public struct ENetProtocolAcknowledge\r\n{\r\n    public ENetProtocolCommandHeader header;\r\n    public uint receivedReliableSequenceNumber;\r\n    public ushort receivedSentTime;\r\n}\r\n\r\npublic struct ENetProtocolConnect\r\n{\r\n    public ENetProtocolCommandHeader header;\r\n    public ushort outgoingPeerID;\r\n    public byte incomingSessionID;\r\n    public byte outgoingSessionID;\r\n    public uint mtu;\r\n    public uint windowSize;\r\n    public uint channelCount;\r\n    public uint incomingBandwidth;\r\n    public uint outgoingBandwidth;\r\n    public uint packetThrottleInterval;\r\n    public uint packetThrottleAcceleration;\r\n    public uint packetThrottleDeceleration;\r\n    public uint connectID;\r\n    public uint data;\r\n}\r\n\r\npublic struct ENetProtocolVerifyConnect\r\n{\r\n    public ENetProtocolCommandHeader header;\r\n    public ushort outgoingPeerID;\r\n    public byte incomingSessionID;\r\n    public byte outgoingSessionID;\r\n    public uint mtu;\r\n    public uint windowSize;\r\n    public uint channelCount;\r\n    public uint incomingBandwidth;\r\n    public uint outgoingBandwidth;\r\n    public uint packetThrottleInterval;\r\n    public uint packetThrottleAcceleration;\r\n    public uint packetThrottleDeceleration;\r\n    public uint connectID;\r\n}\n"})})}),(0,a.jsx)(s.A,{value:"Photon",label:"Photon",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public struct PhotonProtocolAcknowledge\r\n{\r\n    public PhotonProtocolCommandHeader header;\r\n    public uint receivedReliableSequenceNumber;\r\n    public uint receivedSentTime;\r\n}\r\n\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic unsafe struct PhotonProtocolConnect\r\n{\r\n    public PhotonProtocolCommandHeader header;\r\n    public fixed byte payload[32];\r\n}\r\n\r\n[StructLayout(LayoutKind.Sequential)]\r\npublic unsafe struct PhotonProtocolVerifyConnect\r\n{\r\n    public PhotonProtocolCommandHeader header;\r\n    public fixed byte payload[32];\r\n}\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"the-final-result",children:"The final result"}),"\n",(0,a.jsx)(n.p,{children:"What did I achieve?"}),"\n",(0,a.jsx)(n.p,{children:"ENet modifications allow it to work with SotA. I can start my server and listen to port 5057, and the client initiates the connection\r\nhandshake. ENet correctly responds, and the client accepts the connection. After that, the client starts to send the first actual messages to the server.\r\nFirst messages are sent to LoggingServer. LoggingServer main functionality is to receive logs and to provide News of the day, internetradio urls and some minor things.\r\nBut it's the first server game connects to, and it works now."}),"\n",(0,a.jsx)(n.p,{children:"The actual Peer in the ShroudServer application now receives the messages from the client. One of the first messages looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hexdump",children:"F3 02 00 00 02 00 6C 00 00 00 00 66 28 19 81 02 63 01 00 6A 7B 22 30 22 3A 22 4C 6F 67\r\n22 2C 22 31 22 3A 22 53 6F 74 41 2E 57 69 6E 2E 36 34 2E 31 37 39 38 2E 44 61 74 65 2E\r\n31 30 2E 30 36 2E 32 35 2C 20 4C 6F 63 61 6C 54 69 6D 65 3D 31 38 2F 31 30 2F 32 30 32\r\n35 20 32 32 3A 30 33 3A 35 33 2C 20 50 61 74 63 68 3D 42 61 63 6B 54 6F 53 71 75 69 72\r\n72 65 6C 2E 32 30 32 35 22 7D\n"})}),"\n",(0,a.jsx)(n.p,{children:"And after bit of parsing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\r\n  "0" : "Log",\r\n  "1" : "SotA.Win.64.1798.Date.10.06.25, LocalTime=18/10/2025 22:03:53, Patch=BackToSquirrel.2025"\r\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is an actual message from the client. After all this hassle, it does not seem like a big deal, but getting here was a lot of work."}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next steps?"}),"\n",(0,a.jsx)(n.p,{children:"Before I threw the Photon server away, I had all the logging server functionality working and login sequence.\r\nBecause Photon SDK uses .Net 4.8, I had to create a slimy, disgusting bridge between Photon and my ShroudServer.\r\nShroudServer is using latest of everything and those are not compatible. Bridge was done with REST. I now have to create a proper\r\ncommunication layer between my Enet server and the actual ShroudServer. It's not a big deal, but it's the next step."}),"\n",(0,a.jsx)(n.p,{children:"After I get the bridge working, the client should be able to send logging data and receive news of the day etc. from the ShroudServer.\r\nAlso, login should work. When I say login, I mean the actual login sequence, nothing more. There's tons of things to do, before client actually loads\r\nto main world."}),"\n",(0,a.jsx)(n.p,{children:"If you read all this, I hope you enjoyed it. These are something I use to reiterate what I did, so I can remember what I did."}),"\n",(0,a.jsx)(n.p,{children:"-Katu"})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},7747:e=>{e.exports=JSON.parse('{"permalink":"/shroudserver-site/blog/2025/10/19/enet-modifications","source":"@site/blog/2025/10/19-enet-modifications.mdx","title":"ENet modifications and reverse engineering","description":"Technical deep dive into ENet modifications needed for ShroudServer.","date":"2025-10-19T00:00:00.000Z","tags":[{"inline":false,"label":"me","permalink":"/shroudserver-site/blog/tags/me","description":"Blog posts about me"},{"inline":false,"label":"csharp","permalink":"/shroudserver-site/blog/tags/csharp","description":"Blog posts about C#"},{"inline":false,"label":"networking","permalink":"/shroudserver-site/blog/tags/networking","description":"Blog posts about networking"},{"inline":false,"label":"enet","permalink":"/shroudserver-site/blog/tags/enet","description":"Blog posts about ENet networking library"}],"readingTime":10.66,"hasTruncateMarker":true,"authors":[{"name":"Katumies","title":"Dev","imageURL":"https://avatars.githubusercontent.com/u/2749368?v=4&size=64","key":"katumies","page":null}],"frontMatter":{"title":"ENet modifications and reverse engineering","description":"Technical deep dive into ENet modifications needed for ShroudServer.","date":"2025-10-19T00:00:00.000Z","authors":"katumies","tags":["me","csharp","networking","enet"]},"unlisted":false,"nextItem":{"title":"Welcome to ShroudServer devblog","permalink":"/shroudserver-site/blog/welcome"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const a={},o=r.createContext(a);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var r=t(4164);const a={tabItem:"tabItem_Ymn6"};var o=t(4848);function i({children:e,hidden:n,className:t}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(a.tabItem,t),hidden:n,children:e})}}}]);