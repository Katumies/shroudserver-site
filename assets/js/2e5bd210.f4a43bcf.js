"use strict";(globalThis.webpackChunkshroudserver=globalThis.webpackChunkshroudserver||[]).push([[8400],{9193:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/10/19/enet-modifications","metadata":{"permalink":"/shroudserver-site/blog/2025/10/19/enet-modifications","source":"@site/blog/2025/10/19-enet-modifications.mdx","title":"ENet modifications and reverse engineering","description":"Technical deep dive into ENet modifications needed for ShroudServer.","date":"2025-10-19T00:00:00.000Z","tags":[{"inline":false,"label":"me","permalink":"/shroudserver-site/blog/tags/me","description":"Blog posts about me"},{"inline":false,"label":"csharp","permalink":"/shroudserver-site/blog/tags/csharp","description":"Blog posts about C#"},{"inline":false,"label":"networking","permalink":"/shroudserver-site/blog/tags/networking","description":"Blog posts about networking"},{"inline":false,"label":"enet","permalink":"/shroudserver-site/blog/tags/enet","description":"Blog posts about ENet networking library"}],"readingTime":10.66,"hasTruncateMarker":true,"authors":[{"name":"Katumies","title":"Dev","imageURL":"https://avatars.githubusercontent.com/u/2749368?v=4&size=64","key":"katumies","page":null}],"frontMatter":{"title":"ENet modifications and reverse engineering","description":"Technical deep dive into ENet modifications needed for ShroudServer.","date":"2025-10-19T00:00:00.000Z","authors":"katumies","tags":["me","csharp","networking","enet"]},"unlisted":false,"nextItem":{"title":"Welcome to ShroudServer devblog","permalink":"/shroudserver-site/blog/welcome"}},"content":"import Tabs from \'@theme/Tabs\';\\r\\nimport TabItem from \'@theme/TabItem\';\\r\\n\\r\\n## Enet modifications\\r\\n\\r\\nYesterday and today, I have been working on modifying [ENet-CSharp](https://github.com/Molth/enet-csharp) library to work with SotA.\\r\\nI\'ll go through the changes needed and why they were needed.\\r\\n\\r\\nWarning, this is going to be a very technical post.\\r\\n\\r\\n\x3c!-- truncate --\x3e \\r\\n\\r\\n### Background\\r\\n\\r\\nSotA uses Photon networking for all the networking needs. The server they are running is Photon Server v4, and the client\\r\\nuses Photon Unity Networking V1. How do I know all this? Well, I took a look at the game files, and there it is, Photon3Unity3D.dll.\\r\\nThis is the client library for Photon networking. I have spent a few years, with varying interest, to dig out how the game works\\r\\nand more importantly, how the networking works.\\r\\n\\r\\n### Reverse engineering\\r\\nHours and hours of using Wireshark, DotPeek, DnSpy and other tools, I have managed to get a good understanding\\r\\nof the networking protocol used by the game. There is not a lot of public information about the protocol used by Photon,\\r\\nso I had to do a lot of things by myself. Luckily, this year, there been some other projects that have been working on\\r\\nPhoton emulation, and I have been able to learn from them as well. However, none of those tackled the actual ENet modification,\\r\\nbut rather focused on emulating the server. Nothing wrong about that, but I wanted to go deeper.\\r\\n\\r\\n#### Actual reverse engineering\\r\\nWhat do I actually do when I say reverse engineering?\\r\\n\\r\\nFor example, the last few days, I have been working on understanding how the reliable messages are sent and received and also,\\r\\nhow the acknowledgements are handled. This required hours of looking and tracing the code to actually understand that it really\\r\\nmatters that acknowledgements are sent in a specific way. This is one of the modifications ENet needed. I also spent used Wireshark\\r\\nto capture and record the actual packets sent by the client, when it\'s connecting at the game start and also, what the server answers.\\r\\nI saved those packets and used Wireshark to analyze them.\\r\\n\\r\\nNormally, all networking messages are obfuscated, but I have disabled that with the BepInEx plugin I have created for the client.\\r\\nThey obfuscate it by adding a random variable number of random bytes to the start and end or the actual message.\\r\\nThen there are a few places where they drop byte \'55\' (0x37) to work as a marker. Nothing fancy, but it works, I guess.\\r\\nIt surely stops casual packet sniffing. However, they could have enabled encryption also, or instead of sending JSON data,\\r\\nthey could have used a binary format.\\r\\n\\r\\n#### BepInEx plugin\\r\\nTo help with the reverse engineering, I created a BepInEx plugin for the client. It\'s nothing fancy, but it changes all\\r\\nthe addresses the client uses to connect servers and point those addresses to my localhost. I also have added logging here\\r\\nand there to get more information about what the client is doing. I found a way to swap the encryption keys, so I don\'t have\\r\\nto disable encryption used for login passwords etc. I patch the obfuscation method, so it takes a byte array and \\r\\njust returns it as is, instead of adding random bytes.\\r\\n\\r\\nBepInEx is a great modding framework for Unity games, and we are going to use it a lot in this project.\\r\\nSo much could be done with it already.\\r\\n\\r\\n - adding custom UI\'s\\r\\n    - totally new windows that aggregate information from multiple sources\\r\\n - modding existing UI\'s\\r\\n    - sorting changes\\r\\n    - adding new buttons that simplify things\\r\\n - adding new Lua features\\r\\n    - literally anything can be connected to lua scripts within the game data\\r\\n - fixing existing issues with the client.\\r\\n\\r\\nI did say, that this is going to be a technical post, so for the fellow nerds, here is the code snippet that patches the obfuscation method:\\r\\n\\r\\n```csharp\\r\\n    // Find the type information for the PortMessage class\\r\\n    Type type = Type.GetType(\\"Portalarium.Photon.PortMessage, Assembly-CSharp\\");\\r\\n    \\r\\n    // Use type information to get the MethodInfo for the CreateByteArrayData method\\r\\n    MethodInfo createByteArrayDataMethodInfo = type.GetMethod(\\"CreateByteArrayData\\", BindingFlags.NonPublic | BindingFlags.Static);\\r\\n    \\r\\n    // use Harmony to patch the method\\r\\n\\tvar instance = new Harmony(\\"tester\\");\\r\\n\\tinstance.Patch(\\r\\n\\t\\tcreateByteArrayDataMethodInfo,\\r\\n\\t\\tnew HarmonyMethod(typeof(PatchObfuscation).GetMethod(\\"Prefix\\")),\\r\\n\\t\\tnull,\\r\\n\\t\\tnull\\r\\n\\t\\t);\\r\\n\\r\\n    // this is BepInEx Harmony patch class\\r\\n   public class PatchObfuscation\\r\\n    {\\r\\n        // Prefix, executed before the original method, with the ability to modify parameters, reroute execution or set return value.\\r\\n        public static bool Prefix(ref DataBuffer __result, MethodBase __originalMethod, char[] SerializedData, int length)\\r\\n        {\\r\\n            // Here we create new return value for the method and instead of obfuscating the data, we just convert it to DataBuffer as is.\\r\\n            byte[] returnValue = new byte[length];\\r\\n            Encoding.UTF8.GetBytes(SerializedData, 0, length, returnValue, 0);\\r\\n            DataBuffer dataBuffer = new DataBuffer(returnValue);\\r\\n            __result = dataBuffer;\\r\\n\\r\\n            // return false means, that the original method is not executed.\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n```\\r\\nBepInEx is a really powerful tool, and I recommend it for anyone wanting to mod Unity games.\\r\\n\\r\\n#### Wireshark\\r\\n\\r\\nWith Wireshark, I can see what kind of packets are sent between the client and the server. I use [photon-dissector](https://github.com/bennesp/photon-dissector)\\r\\nwith tiny modifications to make it work with this photon version. It is a sort of plugin for Wireshark that allows it to understand and decode\\r\\nthe Photon protocol.\\r\\n\\r\\n![Wireshark screenshot](/img/wireshark/wireshark.jpg)\\r\\n\\r\\n## ENet modifications\\r\\n\\r\\nSo, as previously stated, Photon is built on top of ENet. ENet is the actual networking part of the code. It reads and writes packets\\r\\nto and from the sockets, using UDP protocol. I\'m not going to cover UDP and socket programming, but I will cover the ENet part.\\r\\nOne thing to remember is that Photon is a HUGE software that can do so much more than just UDP networking, so we are not replacing all the\\r\\nfeatures of Photon, only the important ones, UDP layer.\\r\\n\\r\\n#### Main differences\\r\\n\\r\\nAt this time, I can\'t even list all the differences because I may discover more in the future. However, SotA client accepts my\\r\\nserver and starts to communicate with it, so I can assume that the biggest differences have been fixed.\\r\\n\\r\\n\\r\\n##### ProtocolCommands are almost equal\\r\\n\\r\\nRealizing that the protocol at very low level is almost the same for both Photon and Enet, gave me the confidence that this is doable.\\r\\nThese are the protocol commands that are used by both libraries.\\r\\n<Tabs>\\r\\n    <TabItem value=\\"ENet\\" label=\\"ENet\\" default>\\r\\n        ```csharp\\r\\n        public enum ENetProtocolCommand\\r\\n        {\\r\\n            ENET_PROTOCOL_COMMAND_NONE = 0,\\r\\n            ENET_PROTOCOL_COMMAND_ACKNOWLEDGE = 1,\\r\\n            ENET_PROTOCOL_COMMAND_CONNECT = 2,\\r\\n            ENET_PROTOCOL_COMMAND_VERIFY_CONNECT = 3,\\r\\n            ENET_PROTOCOL_COMMAND_DISCONNECT = 4,\\r\\n            ENET_PROTOCOL_COMMAND_PING = 5,\\r\\n            ENET_PROTOCOL_COMMAND_SEND_RELIABLE = 6,\\r\\n            ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE = 7,\\r\\n            ENET_PROTOCOL_COMMAND_SEND_FRAGMENT = 8,\\r\\n            ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED = 9,\\r\\n            ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT = 10,\\r\\n            ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11,\\r\\n            ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,\\r\\n            ENET_PROTOCOL_COMMAND_COUNT = 13,\\r\\n        \\r\\n            ENET_PROTOCOL_COMMAND_MASK = 0x0F\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n    <TabItem value=\\"Photon\\" label=\\"Photon\\">\\r\\n        ```csharp\\r\\n        public enum PhotonProtocolCommand\\r\\n        {\\r\\n            PHOTON_PROTOCOL_COMMAND_NONE = 0,\\r\\n            PHOTON_PROTOCOL_COMMAND_ACKNOWLEDGE = 1,\\r\\n            PHOTON_PROTOCOL_COMMAND_CONNECT = 2,\\r\\n            PHOTON_PROTOCOL_COMMAND_VERIFY_CONNECT = 3,\\r\\n            PHOTON_PROTOCOL_COMMAND_DISCONNECT = 4,\\r\\n            PHOTON_PROTOCOL_COMMAND_PING = 5,\\r\\n            PHOTON_PROTOCOL_COMMAND_SEND_RELIABLE = 6,\\r\\n            PHOTON_PROTOCOL_COMMAND_SEND_UNRELIABLE = 7,\\r\\n            PHOTON_PROTOCOL_COMMAND_SEND_FRAGMENT = 8,\\r\\n            PHOTON_PROTOCOL_COMMAND_SEND_UNSEQUENCED = 9,\\r\\n            //PHOTON_PROTOCOL_COMMAND_BANDWIDTH_LIMIT = 10,\\r\\n            //PHOTON_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11,\\r\\n            //PHOTON_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,\\r\\n            PHOTON_PROTOCOL_COMMAND_SEND_SERVERTIMESTAMP = 12,\\r\\n            PHOTON_PROTOCOL_COMMAND_COUNT = 13,\\r\\n    \\r\\n            PHOTON_PROTOCOL_COMMAND_MASK = 0x0F\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n</Tabs>\\r\\n\\r\\n##### Protocol Headers differ\\r\\n\\r\\nA Big difference between the two protocols is the actual protocol headers used. Photon has more information in the header.\\r\\nENet uses bit-fields to encode data to, for example, peerID. So, the actual maximum peerID is 0xFFF because the last bit\\r\\nis used for bit flags.\\r\\n\\r\\nPhoton has explicit bytes reserved for things needed. It looks like ENet is more efficient, but Photon delivers much more\\r\\ncomplicated data, and it packs the data better, so in the real world, it\'s probably more efficient after all.\\r\\n\\r\\nPeerID functionality and commandCount things caused refactorings here and there. I tried to find a way to make them work\\r\\nall the while keeping ENets features in use. Also, ENet uses the sessionID variable to keep track of the connection, but Photon\\r\\nuses the challenge variable. Photon Marks the packets as reliable by using the command flags and CommandType. \\r\\n\\r\\n\\r\\n<Tabs>\\r\\n    <TabItem value=\\"ENet\\" label=\\"ENet\\" default>\\r\\n        ```csharp\\r\\n        // 8 bytes\\r\\n        public struct ENetProtocolHeader\\r\\n        {\\r\\n            public ushort peerID;\\r\\n            public ushort sentTime;\\r\\n        }\\r\\n\\r\\n        // 6 bytes\\r\\n        public struct ENetProtocolCommandHeader\\r\\n        {\\r\\n            public byte command;\\r\\n            public byte channelID;\\r\\n            public uint reliableSequenceNumber;\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n    <TabItem value=\\"Photon\\" label=\\"Photon\\">\\r\\n        ```csharp\\r\\n        // 12 bytes\\r\\n        public struct PhotonProtocolHeader\\r\\n        {\\r\\n            public ushort peerID;\\r\\n            public byte crcEnabled;\\r\\n            public byte commandCount;\\r\\n            public uint sentTime;\\r\\n            public uint challenge;\\r\\n        }\\r\\n        // 12 bytes\\r\\n        public struct PhotonProtocolCommandHeader\\r\\n        {\\r\\n            public byte commandType;\\r\\n            public byte channelID;\\r\\n            public byte commandFlags;\\r\\n            public byte reservedBytes;\\r\\n            public uint commandLen;\\r\\n            public uint reliableSequenceNumber;\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n</Tabs>\\r\\n\\r\\n\\r\\n\\r\\n##### Connection handshake commands\\r\\n\\r\\nENet has a very different connection handshake. ENet sends tons of data and uses fields that are not present in Photon.\\r\\nENet client decides its own ID, where as Photon uses incremental ID, assigned by the server.\\r\\nSotA clients PUN sends very few fields, most of the \\"connect\\" data is 0.\\r\\nAlso, when the SotA client receives the \\"Verify connect\\" command, it basically ignores everything from the payload.\\r\\nIt only reads two first bytes of it as a peerID. \\r\\n\\r\\nOne big thing I had to change was that acknowledgement for the \\"connect\\" command has to be in the next message sent and\\r\\nit has to be before \\"verify connect\\" in the list of commands. Client reads incoming commands in the order they are sent and if\\r\\n\\"verify connect\\" is received before the \\"connect\\" is acknowledged, it sends the \\"connect\\" command again. This is just a one example\\r\\nof things that just have to be dug out with reverse engineering.\\r\\n\\r\\n<Tabs>\\r\\n    <TabItem value=\\"ENet\\" label=\\"ENet\\" default>\\r\\n        ```csharp\\r\\n        public struct ENetProtocolAcknowledge\\r\\n        {\\r\\n            public ENetProtocolCommandHeader header;\\r\\n            public uint receivedReliableSequenceNumber;\\r\\n            public ushort receivedSentTime;\\r\\n        }\\r\\n\\r\\n        public struct ENetProtocolConnect\\r\\n        {\\r\\n            public ENetProtocolCommandHeader header;\\r\\n            public ushort outgoingPeerID;\\r\\n            public byte incomingSessionID;\\r\\n            public byte outgoingSessionID;\\r\\n            public uint mtu;\\r\\n            public uint windowSize;\\r\\n            public uint channelCount;\\r\\n            public uint incomingBandwidth;\\r\\n            public uint outgoingBandwidth;\\r\\n            public uint packetThrottleInterval;\\r\\n            public uint packetThrottleAcceleration;\\r\\n            public uint packetThrottleDeceleration;\\r\\n            public uint connectID;\\r\\n            public uint data;\\r\\n        }\\r\\n\\r\\n        public struct ENetProtocolVerifyConnect\\r\\n        {\\r\\n            public ENetProtocolCommandHeader header;\\r\\n            public ushort outgoingPeerID;\\r\\n            public byte incomingSessionID;\\r\\n            public byte outgoingSessionID;\\r\\n            public uint mtu;\\r\\n            public uint windowSize;\\r\\n            public uint channelCount;\\r\\n            public uint incomingBandwidth;\\r\\n            public uint outgoingBandwidth;\\r\\n            public uint packetThrottleInterval;\\r\\n            public uint packetThrottleAcceleration;\\r\\n            public uint packetThrottleDeceleration;\\r\\n            public uint connectID;\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n    <TabItem value=\\"Photon\\" label=\\"Photon\\">\\r\\n        ```csharp\\r\\n        public struct PhotonProtocolAcknowledge\\r\\n        {\\r\\n            public PhotonProtocolCommandHeader header;\\r\\n            public uint receivedReliableSequenceNumber;\\r\\n            public uint receivedSentTime;\\r\\n        }\\r\\n\\r\\n        [StructLayout(LayoutKind.Sequential)]\\r\\n        public unsafe struct PhotonProtocolConnect\\r\\n        {\\r\\n            public PhotonProtocolCommandHeader header;\\r\\n            public fixed byte payload[32];\\r\\n        }\\r\\n\\r\\n        [StructLayout(LayoutKind.Sequential)]\\r\\n        public unsafe struct PhotonProtocolVerifyConnect\\r\\n        {\\r\\n            public PhotonProtocolCommandHeader header;\\r\\n            public fixed byte payload[32];\\r\\n        }\\r\\n        ```\\r\\n    </TabItem>\\r\\n</Tabs>\\r\\n\\r\\n\\r\\n## The final result\\r\\n\\r\\nWhat did I achieve?\\r\\n\\r\\nENet modifications allow it to work with SotA. I can start my server and listen to port 5057, and the client initiates the connection \\r\\nhandshake. ENet correctly responds, and the client accepts the connection. After that, the client starts to send the first actual messages to the server.\\r\\nFirst messages are sent to LoggingServer. LoggingServer main functionality is to receive logs and to provide News of the day, internetradio urls and some minor things.\\r\\nBut it\'s the first server game connects to, and it works now.\\r\\n\\r\\nThe actual Peer in the ShroudServer application now receives the messages from the client. One of the first messages looks like this:\\r\\n```hexdump\\r\\nF3 02 00 00 02 00 6C 00 00 00 00 66 28 19 81 02 63 01 00 6A 7B 22 30 22 3A 22 4C 6F 67\\r\\n22 2C 22 31 22 3A 22 53 6F 74 41 2E 57 69 6E 2E 36 34 2E 31 37 39 38 2E 44 61 74 65 2E\\r\\n31 30 2E 30 36 2E 32 35 2C 20 4C 6F 63 61 6C 54 69 6D 65 3D 31 38 2F 31 30 2F 32 30 32\\r\\n35 20 32 32 3A 30 33 3A 35 33 2C 20 50 61 74 63 68 3D 42 61 63 6B 54 6F 53 71 75 69 72\\r\\n72 65 6C 2E 32 30 32 35 22 7D\\r\\n```\\r\\nAnd after bit of parsing\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\"0\\" : \\"Log\\",\\r\\n  \\"1\\" : \\"SotA.Win.64.1798.Date.10.06.25, LocalTime=18/10/2025 22:03:53, Patch=BackToSquirrel.2025\\"\\r\\n}\\r\\n```\\r\\nThis is an actual message from the client. After all this hassle, it does not seem like a big deal, but getting here was a lot of work.\\r\\n\\r\\n## Next steps?\\r\\n\\r\\nBefore I threw the Photon server away, I had all the logging server functionality working and login sequence.\\r\\nBecause Photon SDK uses .Net 4.8, I had to create a slimy, disgusting bridge between Photon and my ShroudServer.\\r\\nShroudServer is using latest of everything and those are not compatible. Bridge was done with REST. I now have to create a proper\\r\\ncommunication layer between my Enet server and the actual ShroudServer. It\'s not a big deal, but it\'s the next step.\\r\\n\\r\\nAfter I get the bridge working, the client should be able to send logging data and receive news of the day etc. from the ShroudServer.\\r\\nAlso, login should work. When I say login, I mean the actual login sequence, nothing more. There\'s tons of things to do, before client actually loads\\r\\nto main world.\\r\\n\\r\\nIf you read all this, I hope you enjoyed it. These are something I use to reiterate what I did, so I can remember what I did.\\r\\n\\r\\n-Katu"},{"id":"/welcome","metadata":{"permalink":"/shroudserver-site/blog/welcome","source":"@site/blog/welcome.mdx","title":"Welcome to ShroudServer devblog","description":"An introduction to my project.","date":"2025-10-16T00:00:00.000Z","tags":[{"inline":false,"label":"me","permalink":"/shroudserver-site/blog/tags/me","description":"Blog posts about me"},{"inline":false,"label":"csharp","permalink":"/shroudserver-site/blog/tags/csharp","description":"Blog posts about C#"},{"inline":false,"label":"networking","permalink":"/shroudserver-site/blog/tags/networking","description":"Blog posts about networking"},{"inline":false,"label":"enet","permalink":"/shroudserver-site/blog/tags/enet","description":"Blog posts about ENet networking library"}],"readingTime":2.95,"hasTruncateMarker":true,"authors":[{"name":"Katumies","title":"Dev","imageURL":"https://avatars.githubusercontent.com/u/2749368?v=4&size=64","key":"katumies","page":null}],"frontMatter":{"title":"Welcome to ShroudServer devblog","description":"An introduction to my project.","date":"2025-10-16T00:00:00.000Z","authors":"katumies","tags":["me","csharp","networking","enet"],"slug":"/welcome"},"unlisted":false,"prevItem":{"title":"ENet modifications and reverse engineering","permalink":"/shroudserver-site/blog/2025/10/19/enet-modifications"}},"content":"## ShroudServer\\r\\n\\r\\nThis blog follows development of a private server for Shroud of the Avatar game. It\'s very much work in progress, but it\'s coming along nicely.\\r\\n\\r\\n\x3c!-- truncate --\x3e\\r\\nShroudServer is hobby project of mine and the target is to create privately hostable server for Shroud of the avatar game. It\'s still very early in development, but certain things, that are techically the hardest, are in good shape and coming up nicely. I assume that readers know something about the game and I might say some keywords that only work in context of the game.\\r\\n\\r\\nI started this blog, to record my doings and to report what is being done. There will be lots of techical jargon and something else, that can be more easily be digested. I\'m willing to share everything I know about the networking and about the needed simulations. I have no fear that someone would try learn this and create their own implementation, infact, this is such a huge task that anyone willing to learn this, sounds good idea to me. I will share detailed information about my findings about network and everything related to the project.\\r\\n\\r\\n### Tiny disclaimer\\r\\nAll the code I have in project, is done by me, everything else is MIT licensed libraries and tools. I don\'t have access to the real server code nor have I ever had. I have not copied any code that is not free to use. I do not represent any company or ideology. It\'s just my hobby project, that for now, only lives on my own development environment.\\r\\n\\r\\n### Tiny About me\\r\\nI\'m Katu, finnish software developer. I have programmed most of my live, in numbers, about 30 years, half of it professionally. I love programming and pushing my self to learn more and more, and thats where this project also started. I have tons of kids and fulltime job, so my freetime for coding is somewhat limited.\\r\\n\\r\\n### Beginnings of the ShroudServer\\r\\n\\r\\nI played the game, Shroud of the Avatar for a good time and many things in the game clicked with me. It pulled me in with endless character templates, somewhat innovative combat system, player owned towns and houses. But, developers of the game, were streched all over the board, everything was in the making, yet nothing was ever done. I did not like some of the decisions made and nowadays just feel bad about the state of the game.\\r\\n\\r\\nSota has a fascinating architecture ( don\'t get too exited, the actual architecture is not fun ) when considering the fact that you can play the game offline and enjoy most of the features without server connection. This led me to think, that maybe the server is not doing that much of work and it could be faked somehow, easily.. (spoiler, not easy)\\r\\n\\r\\n### I had an idea!\\r\\n\\r\\nI\'ll write an private server for the game. Actually, it was not so clear at the time, considering that this happened somewhere between 2021-2022 and just now, It has become clear, that I could actually do this.\\r\\nBUT, I found the good old spark, that has pushed me forward so many times before. Time to learn something new.\\r\\n\\r\\nFast forward to this day and I have gone through few different iterations and I\'m finally thinking, that this is it. I\'m doing it.\\r\\n\\r\\n\\r\\n\\r\\nThis was supposed to be short introduction to the blog and I will try to write about tech, architecture ( game and server ) and most importantly, about the progress. I can\'t promise any deadlines or anykind of set dates for anything basically."}]}}')}}]);